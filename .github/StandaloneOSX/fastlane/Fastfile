fastlane_version "2.226.0"

platform :macOS do
  before_all do
    certificate_path = ENV["APPLE_DISTRIBUTION_CERTIFICATE_PATH"]
    certificate_password = ENV["APPLE_DISTRIBUTION_CERTIFICATE_PASSWORD"]
    installer_certificate_path = ENV["INSTALLER_DISTRIBUTION_CERTIFICATE_PATH"]
    installer_certificate_password = ENV["INSTALLER_DISTRIBUTION_CERTIFICATE_PATH"]
    provisioning_profile_path = ENV["DISTRIBUTION_PROVISIONING_PROFILE_PATH"]
    keychain_name = ENV["KEYCHAIN_NAME"]
    keychain_password = ENV["KEYCHAIN_PASSWORD"]
    
    raise "Missing certificate path" unless certificate_path && !certificate_path.empty?
    raise "Missing certificate password" unless certificate_password && !certificate_password.empty?
    raise "Missing installer certificate path" unless installer_certificate_path && !installer_certificate_path.empty?
    raise "Missing installer certificate password" unless installer_certificate_password && !installer_certificate_password.empty?
    raise "Missing provisioning profile path" unless provisioning_profile_path && !provisioning_profile_path.empty?
    raise "Missing keychain name" unless keychain_name && !keychain_name.empty?
    raise "Missing keychain password" unless keychain_password && !keychain_password.empty?
    
    create_keychain(
      name: keychain_name,
      password: keychain_password,
      default_keychain: true,
      unlock: true,
      timeout: 3600
    )
    
    import_certificate(
      certificate_path: certificate_path,
      certificate_password: certificate_password,
      keychain_name: keychain_name,
      keychain_password: keychain_password
    )

    import_certificate(
      certificate_path: installer_certificate_path,
      certificate_password: installer_certificate_password,
      keychain_name: keychain_name,
      keychain_password: keychain_password
    )
    
    install_provisioning_profile(
      path: provisioning_profile_path
    )
  end

  lane :build do

    app_file_path = ENV["MACOS_APP_FILEPATH"]
    certificate_name = ENV["APPLE_DISTRIBUTION_CERTIFICATE_NAME"]
    installer_certificate_name = ENV["INSTALLER_DISTRIBUTION_CERTIFICATE_NAME"]
    provisioning_profile_path = ENV["DISTRIBUTION_PROVISIONING_PROFILE_PATH"]
    entitlements_file_path = ENV["ENTITLEMENTS_FILE_PATH"]
    app_store_auth_key_path = ENV["APP_STORE_AUTH_KEY_PATH"]
    app_store_issuer_id = ENV["APP_STORE_ISSUER_ID"]
    app_store_key_id = ENV["APP_STORE_KEY_ID"]

    app_absolute_path = File.expand_path("../#{app_file_path}")
    executables = find_executables_in_app_file(app_absolute_path)
    verify_architectures_in_executables(executables)
    remove_extended_attributes_in_app_file(app_absolute_path)
    setup_provisioning_profile_in_app_file(app_absolute_path, provisioning_profile_path)
    codesign_executables_in_app_file(app_absolute_path, executables, certificate_name, entitlements_file_path)
    app_pkg_path = prepare_pkg_file_for_upload(app_absolute_path, installer_certificate_name)

    api_key = app_store_connect_api_key(
      key_id: app_store_key_id,
      issuer_id: app_store_issuer_id,
      key_filepath: app_store_auth_key_path,
      duration: 1200,
    )

    upload_to_testflight(
      api_key: api_key,
      pkg: app_pkg_path,
      skip_waiting_for_build_processing: true
    )
  
    # This would be steps used for Developer ID notarizing and stapling
    # Sign in with Apple is only supported in Development and Production signed builds, 
    # Leaving it here for reference in the future
    # sh("ditto -c -k --sequesterRsrc --keepParent \"#{app_file_path}\" \"#{app_file_path}.zip\"")
    # sh("xcrun notarytool submit \"#{app_file_path}.zip\" --apple-id \"#{apple_username}\" --password \"#{apple_password}\" --team-id \"#{apple_team}\" --wait")
    # sh("xcrun stapler staple \"#{app_file_path}\"")
  end

  def cleanup
    provisioning_profile_path = ENV["DISTRIBUTION_PROVISIONING_PROFILE_PATH"]
    keychain_name = ENV["KEYCHAIN_NAME"]
    
    sh("rm -f #{provisioning_profile_path}")
    delete_keychain(name: keychain_name)
  end

  after_all do
    cleanup
  end

  error do
    cleanup
  end

end

def find_executables_in_app_file(app_path)
  UI.header("Step: Find all executables in .app file")
  executables = sh("find #{app_path} -type f \\( -name \"*.dylib\" -or -perm +111 \\)").split("\n")

  if executables.empty?
    UI.important("âš ï¸ No executables found in #{app_path}")
  else
    UI.success("âœ… Located #{executables.size} executable(s):")
    executables.each { |executable| UI.message(" - #{executable}") }
  end

  return executables
end

def verify_architectures_in_executables(executables)
  UI.header("Step: Verify executable architectures")

  executables.each do |executable|
    missing_architectures = []

    unless system("lipo \"#{executable}\" -verify_arch x86_64 > /dev/null 2>&1")
      missing_architectures << "x86_64"
    end

    unless system("lipo \"#{executable}\" -verify_arch arm64 > /dev/null 2>&1")
      missing_architectures << "arm64"
    end

    if missing_architectures.empty?
      UI.message("âœ… All required architectures are present in #{executable}")
    else
      UI.error("âŒ Missing architectures in #{executable}: #{missing_architectures.join(', ')}")
    end
  end
end

def remove_extended_attributes_in_app_file(app_path)
  UI.header("Step: Remove extended attributes in .app file")
  sh("xattr -crs #{app_path}")
  UI.message("ğŸ§¹ Removed extended attributes from #{app_path}")
end

def setup_provisioning_profile_in_app_file(app_path, provisioning_profile_source_path)
  UI.header("Step: Setup embedded.provisionprofile in .app")

  provisioning_profile_destination_path = File.expand_path("#{app_path}/Contents/embedded.provisionprofile")
  if File.exist?(provisioning_profile_source_path)
    FileUtils.cp(provisioning_profile_source_path, provisioning_profile_destination_path)
    UI.message("ğŸ“„ Provisioning profile copied to #{provisioning_profile_destination_path}")
  else
    UI.error("âŒ Provisioning profile not found at #{provisioning_profile_source_path}")
  end
end

def codesign_executables_in_app_file(app_file_path, executables, certificate_name, entitlements_file_path)
  UI.header("Step: Codesign executables")

  executables.each do |executable|
    # Leave main executable last to be codesigned (with entitlements)
    if executable.include?(".app/Contents/MacOS/")
      next
    end

    # Filter out executables inside .bundle files, so we codesign the .bundle directly
    path_to_codesign = executable
    if match = executable.match(%r{(.*\.bundle)/Contents/MacOS/})
      path_to_codesign = match[1]
    end

    sh("codesign -vvv --force --timestamp --options runtime -s \"#{certificate_name}\" \"#{path_to_codesign}\"")
  end

  # Codesign main app file last
  sh("codesign -vvv --force --timestamp --options runtime -s \"#{certificate_name}\" --entitlements \"#{entitlements_file_path}\" \"#{app_file_path}\"")
end

def prepare_pkg_file_for_upload(app_file_path, installer_certificate_name)
  UI.header("Step: Prepare .pkg file to upload")

  app_pkg_path = app_file_path.sub(/\.app$/, '.pkg')
  sh("productbuild --sign \"#{installer_certificate_name}\" --component \"#{app_file_path}\" \"#{app_pkg_path}\"")

  return app_pkg_path
end
